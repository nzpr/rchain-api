/**
 * Flowtype definitions for RhoTypes_pb
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.10.0
 */

import * as jspb from "google-protobuf";
import * as scalapb_scalapb_pb from "./scalapb/scalapb_pb";
declare export class Par mixins jspb.Message {
  clearSendsList(): void;
  getSendsList(): Array<Send>;
  setSendsList(value: Array<Send>): void;
  addSends(value?: Send, index?: number): Send;
  clearReceivesList(): void;
  getReceivesList(): Array<Receive>;
  setReceivesList(value: Array<Receive>): void;
  addReceives(value?: Receive, index?: number): Receive;
  clearNewsList(): void;
  getNewsList(): Array<New>;
  setNewsList(value: Array<New>): void;
  addNews(value?: New, index?: number): New;
  clearExprsList(): void;
  getExprsList(): Array<Expr>;
  setExprsList(value: Array<Expr>): void;
  addExprs(value?: Expr, index?: number): Expr;
  clearMatchesList(): void;
  getMatchesList(): Array<Match>;
  setMatchesList(value: Array<Match>): void;
  addMatches(value?: Match, index?: number): Match;
  clearUnforgeablesList(): void;
  getUnforgeablesList(): Array<GUnforgeable>;
  setUnforgeablesList(value: Array<GUnforgeable>): void;
  addUnforgeables(value?: GUnforgeable, index?: number): GUnforgeable;
  clearBundlesList(): void;
  getBundlesList(): Array<Bundle>;
  setBundlesList(value: Array<Bundle>): void;
  addBundles(value?: Bundle, index?: number): Bundle;
  clearConnectivesList(): void;
  getConnectivesList(): Array<Connective>;
  setConnectivesList(value: Array<Connective>): void;
  addConnectives(value?: Connective, index?: number): Connective;
  getLocallyfree(): Uint8Array | string;
  getLocallyfree_asU8(): Uint8Array;
  getLocallyfree_asB64(): string;
  setLocallyfree(value: Uint8Array | string): void;
  getConnectiveUsed(): boolean;
  setConnectiveUsed(value: boolean): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Par$AsObject;
  static toObject(includeInstance: boolean, msg: Par): Par$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(message: Par, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Par;
  static deserializeBinaryFromReader(
    message: Par,
    reader: jspb.BinaryReader
  ): Par;
}
export type Par$AsObject = {
  sendsList: Array<Send$AsObject>,
  receivesList: Array<Receive$AsObject>,
  newsList: Array<New$AsObject>,
  exprsList: Array<Expr$AsObject>,
  matchesList: Array<Match$AsObject>,
  unforgeablesList: Array<GUnforgeable$AsObject>,
  bundlesList: Array<Bundle$AsObject>,
  connectivesList: Array<Connective$AsObject>,
  locallyfree: Uint8Array | string,
  connectiveUsed: boolean,
  ...
};
declare export class TaggedContinuation mixins jspb.Message {
  hasParBody(): boolean;
  clearParBody(): void;
  getParBody(): ParWithRandom | void;
  setParBody(value?: ParWithRandom): void;
  hasScalaBodyRef(): boolean;
  clearScalaBodyRef(): void;
  getScalaBodyRef(): number;
  setScalaBodyRef(value: number): void;
  getTaggedContCase(): $Values<typeof TaggedContinuation$TaggedContCase>;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TaggedContinuation$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: TaggedContinuation
  ): TaggedContinuation$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: TaggedContinuation,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): TaggedContinuation;
  static deserializeBinaryFromReader(
    message: TaggedContinuation,
    reader: jspb.BinaryReader
  ): TaggedContinuation;
}
declare var TaggedContinuation: typeof npm$namespace$TaggedContinuation;

declare var npm$namespace$TaggedContinuation: {|
  TaggedContCase: typeof TaggedContinuation$TaggedContCase
|};
export type TaggedContinuation$AsObject = {
  parBody?: ParWithRandom$AsObject,
  scalaBodyRef: number,
  ...
};

declare export var TaggedContinuation$TaggedContCase: {|
  +TAGGED_CONT_NOT_SET: 0, // 0
  +PAR_BODY: 1, // 1
  +SCALA_BODY_REF: 2 // 2
|};
declare export class ParWithRandom mixins jspb.Message {
  hasBody(): boolean;
  clearBody(): void;
  getBody(): Par | void;
  setBody(value?: Par): void;
  getRandomstate(): Uint8Array | string;
  getRandomstate_asU8(): Uint8Array;
  getRandomstate_asB64(): string;
  setRandomstate(value: Uint8Array | string): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ParWithRandom$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: ParWithRandom
  ): ParWithRandom$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ParWithRandom,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ParWithRandom;
  static deserializeBinaryFromReader(
    message: ParWithRandom,
    reader: jspb.BinaryReader
  ): ParWithRandom;
}
export type ParWithRandom$AsObject = {
  body?: Par$AsObject,
  randomstate: Uint8Array | string,
  ...
};
declare export class PCost mixins jspb.Message {
  getCost(): number;
  setCost(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PCost$AsObject;
  static toObject(includeInstance: boolean, msg: PCost): PCost$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: PCost,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): PCost;
  static deserializeBinaryFromReader(
    message: PCost,
    reader: jspb.BinaryReader
  ): PCost;
}
export type PCost$AsObject = {
  cost: number,
  ...
};
declare export class ListParWithRandom mixins jspb.Message {
  clearParsList(): void;
  getParsList(): Array<Par>;
  setParsList(value: Array<Par>): void;
  addPars(value?: Par, index?: number): Par;
  getRandomstate(): Uint8Array | string;
  getRandomstate_asU8(): Uint8Array;
  getRandomstate_asB64(): string;
  setRandomstate(value: Uint8Array | string): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListParWithRandom$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: ListParWithRandom
  ): ListParWithRandom$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ListParWithRandom,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ListParWithRandom;
  static deserializeBinaryFromReader(
    message: ListParWithRandom,
    reader: jspb.BinaryReader
  ): ListParWithRandom;
}
export type ListParWithRandom$AsObject = {
  parsList: Array<Par$AsObject>,
  randomstate: Uint8Array | string,
  ...
};
declare export class Var mixins jspb.Message {
  hasBoundVar(): boolean;
  clearBoundVar(): void;
  getBoundVar(): number;
  setBoundVar(value: number): void;
  hasFreeVar(): boolean;
  clearFreeVar(): void;
  getFreeVar(): number;
  setFreeVar(value: number): void;
  hasWildcard(): boolean;
  clearWildcard(): void;
  getWildcard(): Var$WildcardMsg | void;
  setWildcard(value?: Var$WildcardMsg): void;
  getVarInstanceCase(): $Values<typeof Var$VarInstanceCase>;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Var$AsObject;
  static toObject(includeInstance: boolean, msg: Var): Var$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(message: Var, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Var;
  static deserializeBinaryFromReader(
    message: Var,
    reader: jspb.BinaryReader
  ): Var;
}
declare var Var: typeof npm$namespace$Var;

declare var npm$namespace$Var: {|
  VarInstanceCase: typeof Var$VarInstanceCase,
  WildcardMsg: typeof Var$WildcardMsg
|};
export type Var$AsObject = {
  boundVar: number,
  freeVar: number,
  wildcard?: Var$WildcardMsg$AsObject,
  ...
};

declare export class Var$WildcardMsg mixins jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Var$WildcardMsg$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: Var$WildcardMsg
  ): Var$WildcardMsg$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: Var$WildcardMsg,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): Var$WildcardMsg;
  static deserializeBinaryFromReader(
    message: Var$WildcardMsg,
    reader: jspb.BinaryReader
  ): Var$WildcardMsg;
}

export type Var$WildcardMsg$AsObject = { ... };

declare export var Var$VarInstanceCase: {|
  +VAR_INSTANCE_NOT_SET: 0, // 0
  +BOUND_VAR: 1, // 1
  +FREE_VAR: 2, // 2
  +WILDCARD: 3 // 3
|};
declare export class Bundle mixins jspb.Message {
  hasBody(): boolean;
  clearBody(): void;
  getBody(): Par | void;
  setBody(value?: Par): void;
  getWriteflag(): boolean;
  setWriteflag(value: boolean): void;
  getReadflag(): boolean;
  setReadflag(value: boolean): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Bundle$AsObject;
  static toObject(includeInstance: boolean, msg: Bundle): Bundle$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: Bundle,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): Bundle;
  static deserializeBinaryFromReader(
    message: Bundle,
    reader: jspb.BinaryReader
  ): Bundle;
}
export type Bundle$AsObject = {
  body?: Par$AsObject,
  writeflag: boolean,
  readflag: boolean,
  ...
};
declare export class Send mixins jspb.Message {
  hasChan(): boolean;
  clearChan(): void;
  getChan(): Par | void;
  setChan(value?: Par): void;
  clearDataList(): void;
  getDataList(): Array<Par>;
  setDataList(value: Array<Par>): void;
  addData(value?: Par, index?: number): Par;
  getPersistent(): boolean;
  setPersistent(value: boolean): void;
  getLocallyfree(): Uint8Array | string;
  getLocallyfree_asU8(): Uint8Array;
  getLocallyfree_asB64(): string;
  setLocallyfree(value: Uint8Array | string): void;
  getConnectiveUsed(): boolean;
  setConnectiveUsed(value: boolean): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Send$AsObject;
  static toObject(includeInstance: boolean, msg: Send): Send$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: Send,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): Send;
  static deserializeBinaryFromReader(
    message: Send,
    reader: jspb.BinaryReader
  ): Send;
}
export type Send$AsObject = {
  chan?: Par$AsObject,
  dataList: Array<Par$AsObject>,
  persistent: boolean,
  locallyfree: Uint8Array | string,
  connectiveUsed: boolean,
  ...
};
declare export class ReceiveBind mixins jspb.Message {
  clearPatternsList(): void;
  getPatternsList(): Array<Par>;
  setPatternsList(value: Array<Par>): void;
  addPatterns(value?: Par, index?: number): Par;
  hasSource(): boolean;
  clearSource(): void;
  getSource(): Par | void;
  setSource(value?: Par): void;
  hasRemainder(): boolean;
  clearRemainder(): void;
  getRemainder(): Var | void;
  setRemainder(value?: Var): void;
  getFreecount(): number;
  setFreecount(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ReceiveBind$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: ReceiveBind
  ): ReceiveBind$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ReceiveBind,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ReceiveBind;
  static deserializeBinaryFromReader(
    message: ReceiveBind,
    reader: jspb.BinaryReader
  ): ReceiveBind;
}
export type ReceiveBind$AsObject = {
  patternsList: Array<Par$AsObject>,
  source?: Par$AsObject,
  remainder?: Var$AsObject,
  freecount: number,
  ...
};
declare export class BindPattern mixins jspb.Message {
  clearPatternsList(): void;
  getPatternsList(): Array<Par>;
  setPatternsList(value: Array<Par>): void;
  addPatterns(value?: Par, index?: number): Par;
  hasRemainder(): boolean;
  clearRemainder(): void;
  getRemainder(): Var | void;
  setRemainder(value?: Var): void;
  getFreecount(): number;
  setFreecount(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BindPattern$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: BindPattern
  ): BindPattern$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: BindPattern,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): BindPattern;
  static deserializeBinaryFromReader(
    message: BindPattern,
    reader: jspb.BinaryReader
  ): BindPattern;
}
export type BindPattern$AsObject = {
  patternsList: Array<Par$AsObject>,
  remainder?: Var$AsObject,
  freecount: number,
  ...
};
declare export class ListBindPatterns mixins jspb.Message {
  clearPatternsList(): void;
  getPatternsList(): Array<BindPattern>;
  setPatternsList(value: Array<BindPattern>): void;
  addPatterns(value?: BindPattern, index?: number): BindPattern;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListBindPatterns$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: ListBindPatterns
  ): ListBindPatterns$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ListBindPatterns,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ListBindPatterns;
  static deserializeBinaryFromReader(
    message: ListBindPatterns,
    reader: jspb.BinaryReader
  ): ListBindPatterns;
}
export type ListBindPatterns$AsObject = {
  patternsList: Array<BindPattern$AsObject>,
  ...
};
declare export class Receive mixins jspb.Message {
  clearBindsList(): void;
  getBindsList(): Array<ReceiveBind>;
  setBindsList(value: Array<ReceiveBind>): void;
  addBinds(value?: ReceiveBind, index?: number): ReceiveBind;
  hasBody(): boolean;
  clearBody(): void;
  getBody(): Par | void;
  setBody(value?: Par): void;
  getPersistent(): boolean;
  setPersistent(value: boolean): void;
  getPeek(): boolean;
  setPeek(value: boolean): void;
  getBindcount(): number;
  setBindcount(value: number): void;
  getLocallyfree(): Uint8Array | string;
  getLocallyfree_asU8(): Uint8Array;
  getLocallyfree_asB64(): string;
  setLocallyfree(value: Uint8Array | string): void;
  getConnectiveUsed(): boolean;
  setConnectiveUsed(value: boolean): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Receive$AsObject;
  static toObject(includeInstance: boolean, msg: Receive): Receive$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: Receive,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): Receive;
  static deserializeBinaryFromReader(
    message: Receive,
    reader: jspb.BinaryReader
  ): Receive;
}
export type Receive$AsObject = {
  bindsList: Array<ReceiveBind$AsObject>,
  body?: Par$AsObject,
  persistent: boolean,
  peek: boolean,
  bindcount: number,
  locallyfree: Uint8Array | string,
  connectiveUsed: boolean,
  ...
};
declare export class New mixins jspb.Message {
  getBindcount(): number;
  setBindcount(value: number): void;
  hasP(): boolean;
  clearP(): void;
  getP(): Par | void;
  setP(value?: Par): void;
  clearUriList(): void;
  getUriList(): Array<string>;
  setUriList(value: Array<string>): void;
  addUri(value: string, index?: number): string;
  hasDeployid(): boolean;
  clearDeployid(): void;
  getDeployid(): DeployId | void;
  setDeployid(value?: DeployId): void;
  hasDeployerid(): boolean;
  clearDeployerid(): void;
  getDeployerid(): DeployerId | void;
  setDeployerid(value?: DeployerId): void;
  getLocallyfree(): Uint8Array | string;
  getLocallyfree_asU8(): Uint8Array;
  getLocallyfree_asB64(): string;
  setLocallyfree(value: Uint8Array | string): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): New$AsObject;
  static toObject(includeInstance: boolean, msg: New): New$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(message: New, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): New;
  static deserializeBinaryFromReader(
    message: New,
    reader: jspb.BinaryReader
  ): New;
}
export type New$AsObject = {
  bindcount: number,
  p?: Par$AsObject,
  uriList: Array<string>,
  deployid?: DeployId$AsObject,
  deployerid?: DeployerId$AsObject,
  locallyfree: Uint8Array | string,
  ...
};
declare export class MatchCase mixins jspb.Message {
  hasPattern(): boolean;
  clearPattern(): void;
  getPattern(): Par | void;
  setPattern(value?: Par): void;
  hasSource(): boolean;
  clearSource(): void;
  getSource(): Par | void;
  setSource(value?: Par): void;
  getFreecount(): number;
  setFreecount(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MatchCase$AsObject;
  static toObject(includeInstance: boolean, msg: MatchCase): MatchCase$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: MatchCase,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): MatchCase;
  static deserializeBinaryFromReader(
    message: MatchCase,
    reader: jspb.BinaryReader
  ): MatchCase;
}
export type MatchCase$AsObject = {
  pattern?: Par$AsObject,
  source?: Par$AsObject,
  freecount: number,
  ...
};
declare export class Match mixins jspb.Message {
  hasTarget(): boolean;
  clearTarget(): void;
  getTarget(): Par | void;
  setTarget(value?: Par): void;
  clearCasesList(): void;
  getCasesList(): Array<MatchCase>;
  setCasesList(value: Array<MatchCase>): void;
  addCases(value?: MatchCase, index?: number): MatchCase;
  getLocallyfree(): Uint8Array | string;
  getLocallyfree_asU8(): Uint8Array;
  getLocallyfree_asB64(): string;
  setLocallyfree(value: Uint8Array | string): void;
  getConnectiveUsed(): boolean;
  setConnectiveUsed(value: boolean): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Match$AsObject;
  static toObject(includeInstance: boolean, msg: Match): Match$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: Match,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): Match;
  static deserializeBinaryFromReader(
    message: Match,
    reader: jspb.BinaryReader
  ): Match;
}
export type Match$AsObject = {
  target?: Par$AsObject,
  casesList: Array<MatchCase$AsObject>,
  locallyfree: Uint8Array | string,
  connectiveUsed: boolean,
  ...
};
declare export class Expr mixins jspb.Message {
  hasGBool(): boolean;
  clearGBool(): void;
  getGBool(): boolean;
  setGBool(value: boolean): void;
  hasGInt(): boolean;
  clearGInt(): void;
  getGInt(): number;
  setGInt(value: number): void;
  hasGString(): boolean;
  clearGString(): void;
  getGString(): string;
  setGString(value: string): void;
  hasGUri(): boolean;
  clearGUri(): void;
  getGUri(): string;
  setGUri(value: string): void;
  hasGByteArray(): boolean;
  clearGByteArray(): void;
  getGByteArray(): Uint8Array | string;
  getGByteArray_asU8(): Uint8Array;
  getGByteArray_asB64(): string;
  setGByteArray(value: Uint8Array | string): void;
  hasENotBody(): boolean;
  clearENotBody(): void;
  getENotBody(): ENot | void;
  setENotBody(value?: ENot): void;
  hasENegBody(): boolean;
  clearENegBody(): void;
  getENegBody(): ENeg | void;
  setENegBody(value?: ENeg): void;
  hasEMultBody(): boolean;
  clearEMultBody(): void;
  getEMultBody(): EMult | void;
  setEMultBody(value?: EMult): void;
  hasEDivBody(): boolean;
  clearEDivBody(): void;
  getEDivBody(): EDiv | void;
  setEDivBody(value?: EDiv): void;
  hasEPlusBody(): boolean;
  clearEPlusBody(): void;
  getEPlusBody(): EPlus | void;
  setEPlusBody(value?: EPlus): void;
  hasEMinusBody(): boolean;
  clearEMinusBody(): void;
  getEMinusBody(): EMinus | void;
  setEMinusBody(value?: EMinus): void;
  hasELtBody(): boolean;
  clearELtBody(): void;
  getELtBody(): ELt | void;
  setELtBody(value?: ELt): void;
  hasELteBody(): boolean;
  clearELteBody(): void;
  getELteBody(): ELte | void;
  setELteBody(value?: ELte): void;
  hasEGtBody(): boolean;
  clearEGtBody(): void;
  getEGtBody(): EGt | void;
  setEGtBody(value?: EGt): void;
  hasEGteBody(): boolean;
  clearEGteBody(): void;
  getEGteBody(): EGte | void;
  setEGteBody(value?: EGte): void;
  hasEEqBody(): boolean;
  clearEEqBody(): void;
  getEEqBody(): EEq | void;
  setEEqBody(value?: EEq): void;
  hasENeqBody(): boolean;
  clearENeqBody(): void;
  getENeqBody(): ENeq | void;
  setENeqBody(value?: ENeq): void;
  hasEAndBody(): boolean;
  clearEAndBody(): void;
  getEAndBody(): EAnd | void;
  setEAndBody(value?: EAnd): void;
  hasEOrBody(): boolean;
  clearEOrBody(): void;
  getEOrBody(): EOr | void;
  setEOrBody(value?: EOr): void;
  hasEVarBody(): boolean;
  clearEVarBody(): void;
  getEVarBody(): EVar | void;
  setEVarBody(value?: EVar): void;
  hasEListBody(): boolean;
  clearEListBody(): void;
  getEListBody(): EList | void;
  setEListBody(value?: EList): void;
  hasETupleBody(): boolean;
  clearETupleBody(): void;
  getETupleBody(): ETuple | void;
  setETupleBody(value?: ETuple): void;
  hasESetBody(): boolean;
  clearESetBody(): void;
  getESetBody(): ESet | void;
  setESetBody(value?: ESet): void;
  hasEMapBody(): boolean;
  clearEMapBody(): void;
  getEMapBody(): EMap | void;
  setEMapBody(value?: EMap): void;
  hasEMethodBody(): boolean;
  clearEMethodBody(): void;
  getEMethodBody(): EMethod | void;
  setEMethodBody(value?: EMethod): void;
  hasEMatchesBody(): boolean;
  clearEMatchesBody(): void;
  getEMatchesBody(): EMatches | void;
  setEMatchesBody(value?: EMatches): void;
  hasEPercentPercentBody(): boolean;
  clearEPercentPercentBody(): void;
  getEPercentPercentBody(): EPercentPercent | void;
  setEPercentPercentBody(value?: EPercentPercent): void;
  hasEPlusPlusBody(): boolean;
  clearEPlusPlusBody(): void;
  getEPlusPlusBody(): EPlusPlus | void;
  setEPlusPlusBody(value?: EPlusPlus): void;
  hasEMinusMinusBody(): boolean;
  clearEMinusMinusBody(): void;
  getEMinusMinusBody(): EMinusMinus | void;
  setEMinusMinusBody(value?: EMinusMinus): void;
  hasEModBody(): boolean;
  clearEModBody(): void;
  getEModBody(): EMod | void;
  setEModBody(value?: EMod): void;
  getExprInstanceCase(): $Values<typeof Expr$ExprInstanceCase>;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Expr$AsObject;
  static toObject(includeInstance: boolean, msg: Expr): Expr$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: Expr,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): Expr;
  static deserializeBinaryFromReader(
    message: Expr,
    reader: jspb.BinaryReader
  ): Expr;
}
declare var Expr: typeof npm$namespace$Expr;

declare var npm$namespace$Expr: {|
  ExprInstanceCase: typeof Expr$ExprInstanceCase
|};
export type Expr$AsObject = {
  gBool: boolean,
  gInt: number,
  gString: string,
  gUri: string,
  gByteArray: Uint8Array | string,
  eNotBody?: ENot$AsObject,
  eNegBody?: ENeg$AsObject,
  eMultBody?: EMult$AsObject,
  eDivBody?: EDiv$AsObject,
  ePlusBody?: EPlus$AsObject,
  eMinusBody?: EMinus$AsObject,
  eLtBody?: ELt$AsObject,
  eLteBody?: ELte$AsObject,
  eGtBody?: EGt$AsObject,
  eGteBody?: EGte$AsObject,
  eEqBody?: EEq$AsObject,
  eNeqBody?: ENeq$AsObject,
  eAndBody?: EAnd$AsObject,
  eOrBody?: EOr$AsObject,
  eVarBody?: EVar$AsObject,
  eListBody?: EList$AsObject,
  eTupleBody?: ETuple$AsObject,
  eSetBody?: ESet$AsObject,
  eMapBody?: EMap$AsObject,
  eMethodBody?: EMethod$AsObject,
  eMatchesBody?: EMatches$AsObject,
  ePercentPercentBody?: EPercentPercent$AsObject,
  ePlusPlusBody?: EPlusPlus$AsObject,
  eMinusMinusBody?: EMinusMinus$AsObject,
  eModBody?: EMod$AsObject,
  ...
};

declare export var Expr$ExprInstanceCase: {|
  +EXPR_INSTANCE_NOT_SET: 0, // 0
  +G_BOOL: 1, // 1
  +G_INT: 2, // 2
  +G_STRING: 3, // 3
  +G_URI: 4, // 4
  +G_BYTE_ARRAY: 25, // 25
  +E_NOT_BODY: 5, // 5
  +E_NEG_BODY: 6, // 6
  +E_MULT_BODY: 7, // 7
  +E_DIV_BODY: 8, // 8
  +E_PLUS_BODY: 9, // 9
  +E_MINUS_BODY: 10, // 10
  +E_LT_BODY: 11, // 11
  +E_LTE_BODY: 12, // 12
  +E_GT_BODY: 13, // 13
  +E_GTE_BODY: 14, // 14
  +E_EQ_BODY: 15, // 15
  +E_NEQ_BODY: 16, // 16
  +E_AND_BODY: 17, // 17
  +E_OR_BODY: 18, // 18
  +E_VAR_BODY: 19, // 19
  +E_LIST_BODY: 20, // 20
  +E_TUPLE_BODY: 21, // 21
  +E_SET_BODY: 22, // 22
  +E_MAP_BODY: 23, // 23
  +E_METHOD_BODY: 24, // 24
  +E_MATCHES_BODY: 27, // 27
  +E_PERCENT_PERCENT_BODY: 28, // 28
  +E_PLUS_PLUS_BODY: 29, // 29
  +E_MINUS_MINUS_BODY: 30, // 30
  +E_MOD_BODY: 31 // 31
|};
declare export class EList mixins jspb.Message {
  clearPsList(): void;
  getPsList(): Array<Par>;
  setPsList(value: Array<Par>): void;
  addPs(value?: Par, index?: number): Par;
  getLocallyfree(): Uint8Array | string;
  getLocallyfree_asU8(): Uint8Array;
  getLocallyfree_asB64(): string;
  setLocallyfree(value: Uint8Array | string): void;
  getConnectiveUsed(): boolean;
  setConnectiveUsed(value: boolean): void;
  hasRemainder(): boolean;
  clearRemainder(): void;
  getRemainder(): Var | void;
  setRemainder(value?: Var): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EList$AsObject;
  static toObject(includeInstance: boolean, msg: EList): EList$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EList,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EList;
  static deserializeBinaryFromReader(
    message: EList,
    reader: jspb.BinaryReader
  ): EList;
}
export type EList$AsObject = {
  psList: Array<Par$AsObject>,
  locallyfree: Uint8Array | string,
  connectiveUsed: boolean,
  remainder?: Var$AsObject,
  ...
};
declare export class ETuple mixins jspb.Message {
  clearPsList(): void;
  getPsList(): Array<Par>;
  setPsList(value: Array<Par>): void;
  addPs(value?: Par, index?: number): Par;
  getLocallyfree(): Uint8Array | string;
  getLocallyfree_asU8(): Uint8Array;
  getLocallyfree_asB64(): string;
  setLocallyfree(value: Uint8Array | string): void;
  getConnectiveUsed(): boolean;
  setConnectiveUsed(value: boolean): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ETuple$AsObject;
  static toObject(includeInstance: boolean, msg: ETuple): ETuple$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ETuple,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ETuple;
  static deserializeBinaryFromReader(
    message: ETuple,
    reader: jspb.BinaryReader
  ): ETuple;
}
export type ETuple$AsObject = {
  psList: Array<Par$AsObject>,
  locallyfree: Uint8Array | string,
  connectiveUsed: boolean,
  ...
};
declare export class ESet mixins jspb.Message {
  clearPsList(): void;
  getPsList(): Array<Par>;
  setPsList(value: Array<Par>): void;
  addPs(value?: Par, index?: number): Par;
  getLocallyfree(): Uint8Array | string;
  getLocallyfree_asU8(): Uint8Array;
  getLocallyfree_asB64(): string;
  setLocallyfree(value: Uint8Array | string): void;
  getConnectiveUsed(): boolean;
  setConnectiveUsed(value: boolean): void;
  hasRemainder(): boolean;
  clearRemainder(): void;
  getRemainder(): Var | void;
  setRemainder(value?: Var): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ESet$AsObject;
  static toObject(includeInstance: boolean, msg: ESet): ESet$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ESet,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ESet;
  static deserializeBinaryFromReader(
    message: ESet,
    reader: jspb.BinaryReader
  ): ESet;
}
export type ESet$AsObject = {
  psList: Array<Par$AsObject>,
  locallyfree: Uint8Array | string,
  connectiveUsed: boolean,
  remainder?: Var$AsObject,
  ...
};
declare export class EMap mixins jspb.Message {
  clearKvsList(): void;
  getKvsList(): Array<KeyValuePair>;
  setKvsList(value: Array<KeyValuePair>): void;
  addKvs(value?: KeyValuePair, index?: number): KeyValuePair;
  getLocallyfree(): Uint8Array | string;
  getLocallyfree_asU8(): Uint8Array;
  getLocallyfree_asB64(): string;
  setLocallyfree(value: Uint8Array | string): void;
  getConnectiveUsed(): boolean;
  setConnectiveUsed(value: boolean): void;
  hasRemainder(): boolean;
  clearRemainder(): void;
  getRemainder(): Var | void;
  setRemainder(value?: Var): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EMap$AsObject;
  static toObject(includeInstance: boolean, msg: EMap): EMap$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EMap,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EMap;
  static deserializeBinaryFromReader(
    message: EMap,
    reader: jspb.BinaryReader
  ): EMap;
}
export type EMap$AsObject = {
  kvsList: Array<KeyValuePair$AsObject>,
  locallyfree: Uint8Array | string,
  connectiveUsed: boolean,
  remainder?: Var$AsObject,
  ...
};
declare export class EMethod mixins jspb.Message {
  getMethodname(): string;
  setMethodname(value: string): void;
  hasTarget(): boolean;
  clearTarget(): void;
  getTarget(): Par | void;
  setTarget(value?: Par): void;
  clearArgumentsList(): void;
  getArgumentsList(): Array<Par>;
  setArgumentsList(value: Array<Par>): void;
  addArguments(value?: Par, index?: number): Par;
  getLocallyfree(): Uint8Array | string;
  getLocallyfree_asU8(): Uint8Array;
  getLocallyfree_asB64(): string;
  setLocallyfree(value: Uint8Array | string): void;
  getConnectiveUsed(): boolean;
  setConnectiveUsed(value: boolean): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EMethod$AsObject;
  static toObject(includeInstance: boolean, msg: EMethod): EMethod$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EMethod,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EMethod;
  static deserializeBinaryFromReader(
    message: EMethod,
    reader: jspb.BinaryReader
  ): EMethod;
}
export type EMethod$AsObject = {
  methodname: string,
  target?: Par$AsObject,
  argumentsList: Array<Par$AsObject>,
  locallyfree: Uint8Array | string,
  connectiveUsed: boolean,
  ...
};
declare export class KeyValuePair mixins jspb.Message {
  hasKey(): boolean;
  clearKey(): void;
  getKey(): Par | void;
  setKey(value?: Par): void;
  hasValue(): boolean;
  clearValue(): void;
  getValue(): Par | void;
  setValue(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): KeyValuePair$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: KeyValuePair
  ): KeyValuePair$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: KeyValuePair,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): KeyValuePair;
  static deserializeBinaryFromReader(
    message: KeyValuePair,
    reader: jspb.BinaryReader
  ): KeyValuePair;
}
export type KeyValuePair$AsObject = {
  key?: Par$AsObject,
  value?: Par$AsObject,
  ...
};
declare export class EVar mixins jspb.Message {
  hasV(): boolean;
  clearV(): void;
  getV(): Var | void;
  setV(value?: Var): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EVar$AsObject;
  static toObject(includeInstance: boolean, msg: EVar): EVar$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EVar,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EVar;
  static deserializeBinaryFromReader(
    message: EVar,
    reader: jspb.BinaryReader
  ): EVar;
}
export type EVar$AsObject = {
  v?: Var$AsObject,
  ...
};
declare export class ENot mixins jspb.Message {
  hasP(): boolean;
  clearP(): void;
  getP(): Par | void;
  setP(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ENot$AsObject;
  static toObject(includeInstance: boolean, msg: ENot): ENot$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ENot,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ENot;
  static deserializeBinaryFromReader(
    message: ENot,
    reader: jspb.BinaryReader
  ): ENot;
}
export type ENot$AsObject = {
  p?: Par$AsObject,
  ...
};
declare export class ENeg mixins jspb.Message {
  hasP(): boolean;
  clearP(): void;
  getP(): Par | void;
  setP(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ENeg$AsObject;
  static toObject(includeInstance: boolean, msg: ENeg): ENeg$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ENeg,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ENeg;
  static deserializeBinaryFromReader(
    message: ENeg,
    reader: jspb.BinaryReader
  ): ENeg;
}
export type ENeg$AsObject = {
  p?: Par$AsObject,
  ...
};
declare export class EMult mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EMult$AsObject;
  static toObject(includeInstance: boolean, msg: EMult): EMult$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EMult,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EMult;
  static deserializeBinaryFromReader(
    message: EMult,
    reader: jspb.BinaryReader
  ): EMult;
}
export type EMult$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EDiv mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EDiv$AsObject;
  static toObject(includeInstance: boolean, msg: EDiv): EDiv$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EDiv,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EDiv;
  static deserializeBinaryFromReader(
    message: EDiv,
    reader: jspb.BinaryReader
  ): EDiv;
}
export type EDiv$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EMod mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EMod$AsObject;
  static toObject(includeInstance: boolean, msg: EMod): EMod$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EMod,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EMod;
  static deserializeBinaryFromReader(
    message: EMod,
    reader: jspb.BinaryReader
  ): EMod;
}
export type EMod$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EPlus mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EPlus$AsObject;
  static toObject(includeInstance: boolean, msg: EPlus): EPlus$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EPlus,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EPlus;
  static deserializeBinaryFromReader(
    message: EPlus,
    reader: jspb.BinaryReader
  ): EPlus;
}
export type EPlus$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EMinus mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EMinus$AsObject;
  static toObject(includeInstance: boolean, msg: EMinus): EMinus$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EMinus,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EMinus;
  static deserializeBinaryFromReader(
    message: EMinus,
    reader: jspb.BinaryReader
  ): EMinus;
}
export type EMinus$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class ELt mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ELt$AsObject;
  static toObject(includeInstance: boolean, msg: ELt): ELt$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(message: ELt, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ELt;
  static deserializeBinaryFromReader(
    message: ELt,
    reader: jspb.BinaryReader
  ): ELt;
}
export type ELt$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class ELte mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ELte$AsObject;
  static toObject(includeInstance: boolean, msg: ELte): ELte$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ELte,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ELte;
  static deserializeBinaryFromReader(
    message: ELte,
    reader: jspb.BinaryReader
  ): ELte;
}
export type ELte$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EGt mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EGt$AsObject;
  static toObject(includeInstance: boolean, msg: EGt): EGt$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(message: EGt, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EGt;
  static deserializeBinaryFromReader(
    message: EGt,
    reader: jspb.BinaryReader
  ): EGt;
}
export type EGt$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EGte mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EGte$AsObject;
  static toObject(includeInstance: boolean, msg: EGte): EGte$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EGte,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EGte;
  static deserializeBinaryFromReader(
    message: EGte,
    reader: jspb.BinaryReader
  ): EGte;
}
export type EGte$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EEq mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EEq$AsObject;
  static toObject(includeInstance: boolean, msg: EEq): EEq$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(message: EEq, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EEq;
  static deserializeBinaryFromReader(
    message: EEq,
    reader: jspb.BinaryReader
  ): EEq;
}
export type EEq$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class ENeq mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ENeq$AsObject;
  static toObject(includeInstance: boolean, msg: ENeq): ENeq$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ENeq,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ENeq;
  static deserializeBinaryFromReader(
    message: ENeq,
    reader: jspb.BinaryReader
  ): ENeq;
}
export type ENeq$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EAnd mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EAnd$AsObject;
  static toObject(includeInstance: boolean, msg: EAnd): EAnd$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EAnd,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EAnd;
  static deserializeBinaryFromReader(
    message: EAnd,
    reader: jspb.BinaryReader
  ): EAnd;
}
export type EAnd$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EOr mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EOr$AsObject;
  static toObject(includeInstance: boolean, msg: EOr): EOr$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(message: EOr, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EOr;
  static deserializeBinaryFromReader(
    message: EOr,
    reader: jspb.BinaryReader
  ): EOr;
}
export type EOr$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EMatches mixins jspb.Message {
  hasTarget(): boolean;
  clearTarget(): void;
  getTarget(): Par | void;
  setTarget(value?: Par): void;
  hasPattern(): boolean;
  clearPattern(): void;
  getPattern(): Par | void;
  setPattern(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EMatches$AsObject;
  static toObject(includeInstance: boolean, msg: EMatches): EMatches$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EMatches,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EMatches;
  static deserializeBinaryFromReader(
    message: EMatches,
    reader: jspb.BinaryReader
  ): EMatches;
}
export type EMatches$AsObject = {
  target?: Par$AsObject,
  pattern?: Par$AsObject,
  ...
};
declare export class EPercentPercent mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EPercentPercent$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: EPercentPercent
  ): EPercentPercent$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EPercentPercent,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EPercentPercent;
  static deserializeBinaryFromReader(
    message: EPercentPercent,
    reader: jspb.BinaryReader
  ): EPercentPercent;
}
export type EPercentPercent$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EPlusPlus mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EPlusPlus$AsObject;
  static toObject(includeInstance: boolean, msg: EPlusPlus): EPlusPlus$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EPlusPlus,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EPlusPlus;
  static deserializeBinaryFromReader(
    message: EPlusPlus,
    reader: jspb.BinaryReader
  ): EPlusPlus;
}
export type EPlusPlus$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class EMinusMinus mixins jspb.Message {
  hasP1(): boolean;
  clearP1(): void;
  getP1(): Par | void;
  setP1(value?: Par): void;
  hasP2(): boolean;
  clearP2(): void;
  getP2(): Par | void;
  setP2(value?: Par): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EMinusMinus$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: EMinusMinus
  ): EMinusMinus$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: EMinusMinus,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): EMinusMinus;
  static deserializeBinaryFromReader(
    message: EMinusMinus,
    reader: jspb.BinaryReader
  ): EMinusMinus;
}
export type EMinusMinus$AsObject = {
  p1?: Par$AsObject,
  p2?: Par$AsObject,
  ...
};
declare export class Connective mixins jspb.Message {
  hasConnAndBody(): boolean;
  clearConnAndBody(): void;
  getConnAndBody(): ConnectiveBody | void;
  setConnAndBody(value?: ConnectiveBody): void;
  hasConnOrBody(): boolean;
  clearConnOrBody(): void;
  getConnOrBody(): ConnectiveBody | void;
  setConnOrBody(value?: ConnectiveBody): void;
  hasConnNotBody(): boolean;
  clearConnNotBody(): void;
  getConnNotBody(): Par | void;
  setConnNotBody(value?: Par): void;
  hasVarRefBody(): boolean;
  clearVarRefBody(): void;
  getVarRefBody(): VarRef | void;
  setVarRefBody(value?: VarRef): void;
  hasConnBool(): boolean;
  clearConnBool(): void;
  getConnBool(): boolean;
  setConnBool(value: boolean): void;
  hasConnInt(): boolean;
  clearConnInt(): void;
  getConnInt(): boolean;
  setConnInt(value: boolean): void;
  hasConnString(): boolean;
  clearConnString(): void;
  getConnString(): boolean;
  setConnString(value: boolean): void;
  hasConnUri(): boolean;
  clearConnUri(): void;
  getConnUri(): boolean;
  setConnUri(value: boolean): void;
  hasConnByteArray(): boolean;
  clearConnByteArray(): void;
  getConnByteArray(): boolean;
  setConnByteArray(value: boolean): void;
  getConnectiveInstanceCase(): $Values<
    typeof Connective$ConnectiveInstanceCase
  >;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Connective$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: Connective
  ): Connective$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: Connective,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): Connective;
  static deserializeBinaryFromReader(
    message: Connective,
    reader: jspb.BinaryReader
  ): Connective;
}
declare var Connective: typeof npm$namespace$Connective;

declare var npm$namespace$Connective: {|
  ConnectiveInstanceCase: typeof Connective$ConnectiveInstanceCase
|};
export type Connective$AsObject = {
  connAndBody?: ConnectiveBody$AsObject,
  connOrBody?: ConnectiveBody$AsObject,
  connNotBody?: Par$AsObject,
  varRefBody?: VarRef$AsObject,
  connBool: boolean,
  connInt: boolean,
  connString: boolean,
  connUri: boolean,
  connByteArray: boolean,
  ...
};

declare export var Connective$ConnectiveInstanceCase: {|
  +CONNECTIVE_INSTANCE_NOT_SET: 0, // 0
  +CONN_AND_BODY: 1, // 1
  +CONN_OR_BODY: 2, // 2
  +CONN_NOT_BODY: 3, // 3
  +VAR_REF_BODY: 4, // 4
  +CONN_BOOL: 5, // 5
  +CONN_INT: 6, // 6
  +CONN_STRING: 7, // 7
  +CONN_URI: 8, // 8
  +CONN_BYTE_ARRAY: 9 // 9
|};
declare export class VarRef mixins jspb.Message {
  getIndex(): number;
  setIndex(value: number): void;
  getDepth(): number;
  setDepth(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): VarRef$AsObject;
  static toObject(includeInstance: boolean, msg: VarRef): VarRef$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: VarRef,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): VarRef;
  static deserializeBinaryFromReader(
    message: VarRef,
    reader: jspb.BinaryReader
  ): VarRef;
}
export type VarRef$AsObject = {
  index: number,
  depth: number,
  ...
};
declare export class ConnectiveBody mixins jspb.Message {
  clearPsList(): void;
  getPsList(): Array<Par>;
  setPsList(value: Array<Par>): void;
  addPs(value?: Par, index?: number): Par;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ConnectiveBody$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: ConnectiveBody
  ): ConnectiveBody$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ConnectiveBody,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ConnectiveBody;
  static deserializeBinaryFromReader(
    message: ConnectiveBody,
    reader: jspb.BinaryReader
  ): ConnectiveBody;
}
export type ConnectiveBody$AsObject = {
  psList: Array<Par$AsObject>,
  ...
};
declare export class DeployId mixins jspb.Message {
  getSig(): Uint8Array | string;
  getSig_asU8(): Uint8Array;
  getSig_asB64(): string;
  setSig(value: Uint8Array | string): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DeployId$AsObject;
  static toObject(includeInstance: boolean, msg: DeployId): DeployId$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: DeployId,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): DeployId;
  static deserializeBinaryFromReader(
    message: DeployId,
    reader: jspb.BinaryReader
  ): DeployId;
}
export type DeployId$AsObject = {
  sig: Uint8Array | string,
  ...
};
declare export class DeployerId mixins jspb.Message {
  getPublickey(): Uint8Array | string;
  getPublickey_asU8(): Uint8Array;
  getPublickey_asB64(): string;
  setPublickey(value: Uint8Array | string): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DeployerId$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: DeployerId
  ): DeployerId$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: DeployerId,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): DeployerId;
  static deserializeBinaryFromReader(
    message: DeployerId,
    reader: jspb.BinaryReader
  ): DeployerId;
}
export type DeployerId$AsObject = {
  publickey: Uint8Array | string,
  ...
};
declare export class GUnforgeable mixins jspb.Message {
  hasGPrivateBody(): boolean;
  clearGPrivateBody(): void;
  getGPrivateBody(): GPrivate | void;
  setGPrivateBody(value?: GPrivate): void;
  hasGDeployIdBody(): boolean;
  clearGDeployIdBody(): void;
  getGDeployIdBody(): GDeployId | void;
  setGDeployIdBody(value?: GDeployId): void;
  hasGDeployerIdBody(): boolean;
  clearGDeployerIdBody(): void;
  getGDeployerIdBody(): GDeployerId | void;
  setGDeployerIdBody(value?: GDeployerId): void;
  getUnfInstanceCase(): $Values<typeof GUnforgeable$UnfInstanceCase>;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GUnforgeable$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: GUnforgeable
  ): GUnforgeable$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: GUnforgeable,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): GUnforgeable;
  static deserializeBinaryFromReader(
    message: GUnforgeable,
    reader: jspb.BinaryReader
  ): GUnforgeable;
}
declare var GUnforgeable: typeof npm$namespace$GUnforgeable;

declare var npm$namespace$GUnforgeable: {|
  UnfInstanceCase: typeof GUnforgeable$UnfInstanceCase
|};
export type GUnforgeable$AsObject = {
  gPrivateBody?: GPrivate$AsObject,
  gDeployIdBody?: GDeployId$AsObject,
  gDeployerIdBody?: GDeployerId$AsObject,
  ...
};

declare export var GUnforgeable$UnfInstanceCase: {|
  +UNF_INSTANCE_NOT_SET: 0, // 0
  +G_PRIVATE_BODY: 1, // 1
  +G_DEPLOY_ID_BODY: 2, // 2
  +G_DEPLOYER_ID_BODY: 3 // 3
|};
declare export class GPrivate mixins jspb.Message {
  getId(): Uint8Array | string;
  getId_asU8(): Uint8Array;
  getId_asB64(): string;
  setId(value: Uint8Array | string): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GPrivate$AsObject;
  static toObject(includeInstance: boolean, msg: GPrivate): GPrivate$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: GPrivate,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): GPrivate;
  static deserializeBinaryFromReader(
    message: GPrivate,
    reader: jspb.BinaryReader
  ): GPrivate;
}
export type GPrivate$AsObject = {
  id: Uint8Array | string,
  ...
};
declare export class GDeployId mixins jspb.Message {
  getSig(): Uint8Array | string;
  getSig_asU8(): Uint8Array;
  getSig_asB64(): string;
  setSig(value: Uint8Array | string): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GDeployId$AsObject;
  static toObject(includeInstance: boolean, msg: GDeployId): GDeployId$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: GDeployId,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): GDeployId;
  static deserializeBinaryFromReader(
    message: GDeployId,
    reader: jspb.BinaryReader
  ): GDeployId;
}
export type GDeployId$AsObject = {
  sig: Uint8Array | string,
  ...
};
declare export class GDeployerId mixins jspb.Message {
  getPublickey(): Uint8Array | string;
  getPublickey_asU8(): Uint8Array;
  getPublickey_asB64(): string;
  setPublickey(value: Uint8Array | string): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GDeployerId$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: GDeployerId
  ): GDeployerId$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: GDeployerId,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): GDeployerId;
  static deserializeBinaryFromReader(
    message: GDeployerId,
    reader: jspb.BinaryReader
  ): GDeployerId;
}
export type GDeployerId$AsObject = {
  publickey: Uint8Array | string,
  ...
};
